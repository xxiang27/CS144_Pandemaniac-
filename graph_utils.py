# -*- coding: utf-8 -*-
"""CS144_Pandemaniac.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1kPqDgLNvitW9yQgl8gMz1F-Rwrhy1qSa

# Imports
"""

import sys
import json
import random
import networkx as nx
import numpy as np

"""# File I/O"""

def parse_file(filename):
  info = filename.split(".")
  num_players = info[0]
  num_seeds = int(info[1])
  id = info[2]
  return num_players, num_seeds, id

def parse_graph(filename):
  with open(filename, 'r') as f:
      data = json.load(f)

  # Create a networkx graph from our adjacency list data
  G = nx.from_dict_of_lists(data)

  return G

def write_output(filename, nodes, k):
  output = open(filename, 'w')
  for i in range(50):
    for j in range(k):
      output.write(str(nodes[j]) + "\n")
  output.close()

"""# Helper Functions"""

def choose_top_k(g, k, centrality):
  centralities = centrality(g)
  return [x[0] 
  for x in 
      sorted(centralities.items(), key=lambda x: x[1], reverse=True)[:k]]

def get_proportions(k,subgraphs,G):
  N = G.number_of_nodes()
  proportion = []
  for subgraph in subgraphs:
    s = subgraph.number_of_nodes()
    proportion.append(int(np.round(s/N) * k))
  return proportion

def get_nodes(G, k, centrality):
  s = nx.algorithms.components.connected_components(G)
  subgraphs = [G.subgraph(c).copy() for c in nx.connected_components(G)]
  props = get_proportions(k, subgraphs,G)
  nodes = []
  for i, s in enumerate(subgraphs):
    subnodes = choose_top_k(s, props[i], centrality)
    for n in subnodes:
      nodes.append(n)
  return nodes

def random_sample_k(G, k, factor, centrality):
  nodes = get_nodes(G, factor * k, centrality)
  return random.sample(nodes, k)

"""# Custom Centrality Metrics

## Neighbor Degree / Degree Ratio `deg_ndeg_ratio`
Computes the ratio between the degree of a node and the average degree of its neighbors.
Returns a dictionary of all nodes and their ratio values
"""

def deg_ndeg_ratio(g):
  ratios = {}
  for n in g.nodes():
    degree = g.degree(n)
    if degree == 0:
      ratios[n] = 0
      continue
    neighbors = g.neighbors(n)
    neighbor_avg = sum([g.degree(i) for i in neighbors]) / degree
    retval = 0
    if neighbor_avg > 0:
      result = degree / neighbor_avg
      ratios[n] = result
  return ratios

"""# Processing

## `compute_nodes`
Run this function to create an output file given an input graph.

### Parameters:
`filepath`: path to .json file of the graph

`centrality`: function to compute centrality metric

`k` _(optional)_: number of seed nodes to calculate (if not given, it will be read from the filename of the graph)

`factor` _(optional)_: the initial selection will choose `factor * k` nodes, then randomly select `k` nodes from that set (default is 2)
"""

def compute_nodes(filepath, centrality, k=None, factor=2, write=False):
  filename = filepath.split("/")[-1]
  G = parse_graph(filepath)
  if k is None:
    num_players, k, id = parse_file(filename)
  nodes = random_sample_k(G, k, factor, centrality)
  print(nodes)
  if write:
    write_output(f'{filename.rstrip(".json")}.txt', nodes, k)
  return nodes
